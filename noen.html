<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Merry Christmas My Love</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Montserrat', sans-serif; }
        canvas { display: block; touch-action: none; }
        
        /* --- GIAO DI·ªÜN (UI) ƒê√É CƒÇN CH·ªàNH --- */
        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            /* ƒê·∫©y n·ªôi dung ra 2 ƒë·∫ßu: Ch·ªØ l√™n ƒë·ªânh, Hint xu·ªëng ƒë√°y */
            justify-content: space-between; 
            align-items: center;
            pointer-events: none;
            z-index: 10;
            padding: 50px 20px; /* Kho·∫£ng c√°ch an to√†n cho tai th·ªè iPhone */
            box-sizing: border-box;
        }

        h1 {
            font-family: 'Great Vibes', cursive;
            /* T·ª± ƒë·ªông ch·ªânh c·ª° ch·ªØ theo chi·ªÅu r·ªông m√†n h√¨nh (Responsive) */
            font-size: clamp(3rem, 10vw, 6rem); 
            color: #fff;
            margin: 0;
            text-shadow: 0 0 10px #ff0000, 0 0 20px #ff0000, 0 0 40px #ff00de;
            animation: textGlow 2s infinite alternate;
            text-align: center;
            line-height: 1.2;
            margin-top: 20px; /* C√°ch m√©p tr√™n m·ªôt ch√∫t */
        }

        /* Tr√°i tim ƒë·∫≠p */
        .heart { display: inline-block; animation: beat 1s infinite; }
        @keyframes beat { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }

        #music-hint {
            color: white; font-size: 14px; opacity: 0.8;
            margin-bottom: 30px; /* C√°ch m√©p d∆∞·ªõi */
            animation: blink 2s infinite; 
            pointer-events: auto; cursor: pointer;
            text-shadow: 0 0 5px #fff;
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.2);
        }

        @keyframes textGlow {
            from { text-shadow: 0 0 10px #fff, 0 0 20px #ff0000; opacity: 0.9; }
            to { text-shadow: 0 0 20px #fff, 0 0 30px #ff4da6, 0 0 40px #ff0000; opacity: 1; }
        }
        @keyframes blink { 0% { opacity: 0.3; } 50% { opacity: 1; } 100% { opacity: 0.3; } }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; pointer-events: none;
        }

        /* --- POPUP RESPONSIVE --- */
        #gift-modal {
            display: none; 
            position: fixed; /* D√πng fixed ƒë·ªÉ full m√†n h√¨nh ƒëi·ªán tho·∫°i */
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
            transition: opacity 0.3s ease;
        }

        .modal-content {
            background: #fff;
            padding: 25px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.8);
            width: 85%; /* R·ªông 85% m√†n h√¨nh */
            max-width: 400px;
            border: 3px solid #c0392b;
            animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
        }

        #gift-image {
            width: 100%;
            height: 250px; /* Chi·ªÅu cao v·ª´a ph·∫£i cho mobile */
            object-fit: cover;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 2px solid #e74c3c;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .modal-content h2 {
            color: #c0392b; font-family: 'Great Vibes', cursive;
            font-size: 2.2rem; margin: 0 0 15px; line-height: 1.2;
        }

        #typing-container {
            min-height: 80px; margin-bottom: 20px; text-align: left; padding: 0 5px;
        }

        #typing-text {
            color: #333; font-size: 1rem; line-height: 1.5; margin: 0; font-weight: 500; display: inline;
        }

        .cursor { display: inline-block; width: 2px; height: 1.2rem; background-color: #333; margin-left: 2px; animation: blinkCursor 0.8s infinite; vertical-align: middle; }
        @keyframes blinkCursor { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

        .close-btn {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white; border: none; padding: 12px 35px;
            font-size: 1.1rem; border-radius: 50px; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s; font-weight: bold;
            box-shadow: 0 4px 15px rgba(192, 57, 43, 0.4);
            -webkit-tap-highlight-color: transparent;
        }
        .close-btn:hover { transform: scale(1.05); box-shadow: 0 6px 20px rgba(192, 57, 43, 0.6); }
        @keyframes popIn { from { transform: scale(0.8); opacity: 0; } to { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>
    <audio id="bgMusic" loop>
        <source src="audio.mp3" type="audio/mpeg">
    </audio>

    <div id="loading">ƒêang t·∫£i...</div>
    
    <div id="overlay">
        <h1>Merry Christmas<br>My Love <span class="heart">‚ù§Ô∏è</span></h1>
        
        <div id="music-hint">‚ô´ Ch·∫°m nh·∫π m√†n h√¨nh ƒë·ªÉ m·ªü nh·∫°c & qu√†</div>
    </div>

    <div id="gift-modal">
        <div class="modal-content">
            <img src="" alt="Gift Image" id="gift-image">
            <h2 id="gift-title">G·ª≠i em y√™u!</h2>
            <div id="typing-container">
                <span id="typing-text"></span><span class="cursor"></span>
            </div>
            <button class="close-btn" onclick="closeModal()">Y√™u anh ‚ù§Ô∏è</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- DATA ---
        const wishes = [
            "Ch√∫c em c√≥ m·ªôt m√πa Gi√°ng Sinh th·∫≠t ·∫•m √°p, h·∫°nh ph√∫c b√™n anh! üéÑ‚ù§Ô∏è",
            "M·ªôt m√≥n qu√† nh·ªè gi√†nh t·∫∑ng em y√™u xem cho ƒë·ª° ch√°n nh√≥ hihi. Merry Christmas! ‚ùÑÔ∏èüéÅ",
            "C·∫£m ∆°n em ƒë√£ ƒë·∫øn v√† l√†m cu·ªôc s·ªëng c·ªßa anh r·ª±c r·ª° nh∆∞ c√¢y th√¥ng n√†y. M√£i y√™u em! üíñ‚ú®",
            "∆Ø·ªõc g√¨ b√¢y gi·ªù c√≥ th·ªÉ ƒëi ch∆°i noen v·ªõi em y√™u hen th√¨ c√≤n g√¨ tuy·ªát v·ªùi b·∫±ng üåü‚òÉÔ∏è",
            "Em y√™u h√£y c√πng anh nguy·ªán ∆∞·ªõc 1 ƒëi·ªÅu ∆∞·ªõc trong ƒë√™m gi√°ng sinh heü•∞üíï"
        ];
        const images = [
            "https://images.unsplash.com/photo-1543589077-47d81606c1bf?auto=format&fit=crop&w=600&q=80",
            "avt1.jpg",
            "avt2.jpg",
            "avt3.jpg",
            "avt4.jpg"
        ];

        // --- LOGIC ---
        let typingTimeout;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const giftMeshes = []; 
        let musicPlaying = false;

        function openModal() {
            const modal = document.getElementById('gift-modal');
            const textElement = document.getElementById('typing-text');
            const imgElement = document.getElementById('gift-image');

            const randomWish = wishes[Math.floor(Math.random() * wishes.length)];
            const randomImg = images[Math.floor(Math.random() * images.length)];

            imgElement.src = randomImg;
            textElement.innerHTML = ""; 
            modal.style.display = 'flex';

            let i = 0;
            clearTimeout(typingTimeout);
            function typeWriter() {
                if (i < randomWish.length) {
                    textElement.innerHTML += randomWish.charAt(i);
                    i++;
                    const randomSpeed = Math.floor(Math.random() * 30) + 20;
                    typingTimeout = setTimeout(typeWriter, randomSpeed);
                }
            }
            typeWriter();
        }

        function closeModal() {
            document.getElementById('gift-modal').style.display = 'none';
            clearTimeout(typingTimeout);
        }

        function onInteract(event) {
            const audio = document.getElementById('bgMusic');
            if (!musicPlaying) {
                audio.play().then(() => {
                    musicPlaying = true;
                    document.getElementById('music-hint').style.display = 'none';
                }).catch(e => {});
            }

            if(document.getElementById('gift-modal').style.display !== 'flex') {
                // L·∫•y t·ªça ƒë·ªô touch ho·∫∑c click ch√≠nh x√°c
                let clientX, clientY;
                if(event.changedTouches) {
                    clientX = event.changedTouches[0].clientX;
                    clientY = event.changedTouches[0].clientY;
                } else {
                    clientX = event.clientX;
                    clientY = event.clientY;
                }

                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(giftMeshes, true);
                if (intersects.length > 0) openModal();
            }
        }
        
        window.addEventListener('click', onInteract);
        window.addEventListener('touchstart', onInteract, {passive: false});

        // --- THREE.JS SCENE ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);
        
        // --- H√ÄM CƒÇN CH·ªàNH CAMERA CHO MOBILE ---
        function adjustCamera() {
            const aspect = window.innerWidth / window.innerHeight;
            if (aspect < 1) {
                // M√†n h√¨nh d·ªçc (ƒêi·ªán tho·∫°i): L√πi xa ra ƒë·ªÉ th·∫•y h·∫øt c√¢y
                camera.position.set(0, 150, 1600); 
            } else {
                // M√†n h√¨nh ngang (PC): ƒê·ªÉ g·∫ßn h∆°n
                camera.position.set(0, 150, 900); 
            }
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
        }
        adjustCamera(); // Ch·∫°y ngay khi t·∫£i

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        // T·ªëi ∆∞u pixel cho iPhone Retina (max = 2)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        document.getElementById('loading').style.display = 'none';

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;
        controls.enablePan = false; // T·∫Øt di chuy·ªÉn ngang ƒë·ªÉ tr√°nh l·ªách b·ªë c·ª•c
        controls.maxPolarAngle = Math.PI / 2 - 0.1;

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        // --- OBJECTS (TEXTURES, TREE, GIFTS...) ---
        function createLightTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255,255,255,1)'); grad.addColorStop(0.4, 'rgba(255,255,255,0.5)'); grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 32, 32);
            return new THREE.Texture(canvas);
        }
        const lightTexture = createLightTexture(); lightTexture.needsUpdate = true;

        function createSnowflakeTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.fillRect(0, 0, 32, 32);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.lineCap = 'round';
            ctx.save(); ctx.translate(16, 16);
            for (let i = 0; i < 6; i++) {
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -14); ctx.moveTo(0, -8); ctx.lineTo(-4, -10); ctx.moveTo(0, -8); ctx.lineTo(4, -10);
                ctx.stroke(); ctx.rotate(Math.PI / 3);
            }
            ctx.restore();
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 8);
            grad.addColorStop(0, 'rgba(255,255,255,0.8)'); grad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad; ctx.fill();
            return new THREE.Texture(canvas);
        }
        const snowTexture = createSnowflakeTexture(); snowTexture.needsUpdate = true;

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(3000, 3000), new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide, depthWrite: false }));
        ground.rotation.x = -Math.PI / 2; ground.position.y = -300; scene.add(ground);

        const treeGroup = new THREE.Group(); scene.add(treeGroup);
        const particleCount = 18000;
        const geom = new THREE.BufferGeometry();
        const positions = [], colors = [], sizes = [];
        const c1 = new THREE.Color(0x2ecc71), c2 = new THREE.Color(0xe74c3c), c3 = new THREE.Color(0xf1c40f);
        
        for (let i = 0; i < particleCount; i++) {
            const y = (Math.random() * 600) - 300; 
            const progress = (y + 300) / 600;
            const maxRadius = 250 * (1 - progress);
            const angle = i * 0.1 + y * 0.02;
            const r = maxRadius + (Math.random() - 0.5) * 20;
            positions.push(Math.cos(angle) * r, y, Math.sin(angle) * r);
            const rand = Math.random();
            if (rand > 0.97) { colors.push(c2.r, c2.g, c2.b); sizes.push(15); }
            else if (rand > 0.94) { colors.push(c3.r, c3.g, c3.b); sizes.push(15); }
            else { colors.push(c1.r, c1.g*(0.5+Math.random()*0.5), c1.b); sizes.push(5); }
        }
        geom.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geom.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geom.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
        treeGroup.add(new THREE.Points(geom, new THREE.PointsMaterial({ size: 6, map: lightTexture, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.9 })));

        // Star
        const shape = new THREE.Shape(); const pts=5; const ang=Math.PI/2; 
        for(let i=0; i<pts*2; i++){ const a=ang+(i*Math.PI/pts); const r=(i%2===0)?40:20; i===0?shape.moveTo(Math.cos(a)*r,Math.sin(a)*r):shape.lineTo(Math.cos(a)*r,Math.sin(a)*r); } shape.closePath();
        const sGeo = new THREE.ExtrudeGeometry(shape, {depth:10, bevelEnabled:true, bevelThickness:2, bevelSize:1, bevelSegments:2});
        const sMat = new THREE.MeshPhongMaterial({color:0xffd700, emissive:0xffaa00, emissiveIntensity:1.2, specular:0x000000, shininess:0});
        const realStar = new THREE.Mesh(sGeo, sMat); realStar.position.set(0,326,0);
        treeGroup.add(realStar);
        
        const sGlow = new THREE.Points(new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute([0,340,0],3)), new THREE.PointsMaterial({color:0xffaa00, size:300, map:lightTexture, blending:THREE.AdditiveBlending, depthWrite:false, transparent:true, opacity:0.7}));
        treeGroup.add(sGlow);
        const starLight = new THREE.PointLight(0xffaa00, 2.5, 1000); starLight.position.set(0,350,40); treeGroup.add(starLight);

        // Gifts
        function createGift(color, x, z, ry, size) {
            const box = new THREE.Mesh(new THREE.BoxGeometry(size,size,size), new THREE.MeshPhongMaterial({color:color, shininess:80}));
            box.position.set(x, -300+size/2, z); box.rotation.y = ry;
            const rib = new THREE.MeshBasicMaterial({color:0xffffff});
            box.add(new THREE.Mesh(new THREE.BoxGeometry(size+1,size,size*0.2), rib));
            box.add(new THREE.Mesh(new THREE.BoxGeometry(size*0.2,size,size+1), rib));
            treeGroup.add(box); giftMeshes.push(box);
        }
        for (let i = 0; i < 30; i++) {
            const angle = Math.random()*Math.PI*2; const rad = 30+Math.random()*100;
            createGift(Math.random()*0xffffff, Math.cos(angle)*rad, Math.sin(angle)*rad, Math.random()*Math.PI, 15+Math.random()*15);
        }

        // Bg Stars
        const bgGeo = new THREE.BufferGeometry(); const bgPos=[]; for(let i=0;i<1500;i++) bgPos.push((Math.random()-0.5)*3000,(Math.random()-0.5)*3000,(Math.random()-0.5)*3000);
        bgGeo.setAttribute('position', new THREE.Float32BufferAttribute(bgPos, 3));
        scene.add(new THREE.Points(bgGeo, new THREE.PointsMaterial({color: 0xffffff, size: 3, transparent: true, opacity: 0.8, map: lightTexture})));

        // Ornaments
        const ornaments = [];
        for(let i=0; i<50; i++) {
            const orb = new THREE.Mesh(new THREE.SphereGeometry(6,16,16), new THREE.MeshPhongMaterial({color:Math.random()>0.5?0xff0000:0xffff00, emissive:0x220000}));
            const y=(Math.random()*500)-250; const r=(240*(1-((y+300)/600)))+20; const a=Math.random()*Math.PI*2;
            orb.position.set(Math.cos(a)*r, y, Math.sin(a)*r);
            ornaments.push({mesh:orb, speed:1+Math.random()*3, offset:Math.random()*10});
            treeGroup.add(orb);
        }

        const ribbonPos = []; for(let i=0; i<2000; i++) { const p=i/2000, y=(p*600)-300, r=(260*(1-p))+20, a=p*25; ribbonPos.push(Math.cos(a)*r, y, Math.sin(a)*r); }
        treeGroup.add(new THREE.Points(new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(ribbonPos, 3)), new THREE.PointsMaterial({ color: 0x00ffff, size: 8, map: lightTexture, blending: THREE.AdditiveBlending, depthWrite: false, transparent: true })));
        
        const snowPos = [], snowVel = []; for(let i=0; i<2000; i++) { snowPos.push((Math.random()-0.5)*2000, (Math.random()-0.5)*2000, (Math.random()-0.5)*2000); snowVel.push((Math.random()-0.5)*0.5, (Math.random()*2)+1, (Math.random()-0.5)*0.5); }
        const snowGeo = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3)); snowGeo.userData = { vel: snowVel };
        const snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 15, map: snowTexture, transparent: true, opacity: 0.8, depthWrite: false, blending: THREE.AdditiveBlending }));
        scene.add(snowSystem);

        // --- ANIMATION ---
        let time = 0;
        function animate() {
            requestAnimationFrame(animate); time += 0.01;
            controls.update();
            const sPos = snowSystem.geometry.attributes.position.array, sVel = snowSystem.geometry.userData.vel;
            for(let i=0; i<2000; i++) { const i3=i*3; sPos[i3+1]-=sVel[i3+1]; sPos[i3]+=Math.sin(time+sPos[i3+1]*0.01)*0.5; sPos[i3+2]+=Math.cos(time+sPos[i3+1]*0.01)*0.5; if(sPos[i3+1]<-1000) { sPos[i3+1]=1000; sPos[i3]=(Math.random()-0.5)*2000; sPos[i3+2]=(Math.random()-0.5)*2000; } }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            
            starLight.intensity = 2.5 + Math.sin(time * 3) * 0.5;
            realStar.material.emissiveIntensity = 1.2 + Math.sin(time * 3) * 0.3;
            
            ornaments.forEach(item => {
                const blink = Math.sin(time * item.speed + item.offset);
                item.mesh.material.emissiveIntensity = blink > 0 ? 1 : 0.2;
                const scale = 1 + blink * 0.1;
                item.mesh.scale.set(scale, scale, scale);
            });
            renderer.render(scene, camera);
        }
        
        window.addEventListener('resize', () => { 
            renderer.setSize(window.innerWidth, window.innerHeight);
            adjustCamera(); // T·ª± ƒë·ªông ch·ªânh l·∫°i khi xoay ngang/d·ªçc
        });
        animate();
    </script>
</body>

</html>
